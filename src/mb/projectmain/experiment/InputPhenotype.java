package mb.projectmain.experiment;

import java.util.ArrayList;
import java.util.List;

import mb.ctrnn.core.CTRNN;
import mb.ctrnn.layout.CTRNNLayout;
import mb.evolution.CoEvoPhenotype;
import mb.evolution.Individual;
import mb.projectmain.experiment.inputs.InputProvider;
import mb.projectmain.experiment.params.Parameters;
import mb.util.StatsUtils;

/**
 * Provides fitness functions for the tests/input evolution.
 * 
 * @author Miles Bryant <mb459@sussex.ac.uk>
 *
 */
public class InputPhenotype implements CoEvoPhenotype {
	
	/**
	 * Creates a new InputPhenotype with the specified input and network layouts
	 * 
	 * @param provider
	 *            InputProvider to use
	 * @param layout
	 *            Evolvable layout to load models with
	 * @param params
	 *            Experiment parameters
	 */
	public InputPhenotype ( InputProvider provider, CTRNNLayout layout, Parameters.NetPropertiesParams params ) {
		this.provider = provider;
		this.layout = layout;
		this.params = params;
	}
	
	private final InputProvider						provider;
	private final CTRNNLayout						layout;
	private final Parameters.NetPropertiesParams	params;
	
	/**
	 * Calculates the variance that the InputProvider generated by the genes
	 * provided, creates in the population of candidate models.
	 * @param individuals List of Individuals representing candidate model genotypes
	 * @param genes float array of genes to generate InputProvider with
	 * @returns scalar value of fitness, with higher being better.
	 */
	@Override
	public float calculateFitness( List<Individual> individuals, float[] genes ) {
		
		List<float[]> timeSeries = getNetOutputs( individuals, genes, params.run_length_steps );
		
		float[] meanTimeSeries = StatsUtils.calculateMeansOfArrays( timeSeries );
		List<float[]> variances = StatsUtils.calculateVarianceWithMeans( timeSeries, meanTimeSeries );
		float[] aveVarianceTS = StatsUtils.calculateMeansOfArrays( variances );
		float average = StatsUtils.calculateMean( aveVarianceTS );
		
		return average;
	}
	
	/**
	 * Calculates CTRNN outputs.
	 * @param individuals List of model individuals
	 * @param genes
	 * @param runLength
	 * @return
	 */
	private List<float[]> getNetOutputs( List<Individual> individuals, float[] genes, int runLength ) {
		List<float[]> outputs = new ArrayList<>( individuals.size() );
		provider.setParams( genes );
		
		for ( int i = 0; i < individuals.size(); i++ ) {
			layout.updateGenes( individuals.get( i ).getGenotype().getGenes() );
			
			//calculate CTRNN outputs
			CTRNN net = layout.createCTRNN();
			float[] input = new float[layout.getNumberOfNeurons()];
			float[] output = new float[runLength];
			
			for ( int t = 0; t < runLength; t++ ) {
				input[params.network_input_index] = provider.getInput( t );
				net.step( params.time_step, input );
				output[t] = net.getOutputs()[params.network_output_index];
			}
			outputs.add( output );
		}
		
		return outputs;
	}
	
	@Override
	public int getGenotypeLength() {
		return provider.getNumParams();
	}
}
